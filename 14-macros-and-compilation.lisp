(defpackage :chapter-14
  (:use :cl))

(in-package :chapter-14)

;;; Macros and Compilation

;;; INTRODUCTION


#|
Macro functions, or macros for short, are a way to extend the syntax of Lisp.

In this chapter we will use evaltrace diagrams and a little tool called PPMX
(defined in the Lisp Toolkit section) to see how macros work. There will be a
few references to material in previous Advanced Topics sections, but you’ll be
told where to look if you haven’t read those sections before.

In the second half of the chapter we’ll take a look at compilation. If you
decide one of your programs runs too slowly, compiling it is an easy way to
make it faster. The compiler translates Lisp programs into machine language
programs, which can result in a 10 to 100 times speedup.
|#

;;; 14.2 MACROS AS SHORTHAND


#|
Think of macros as the computer equivalent of shorthand. Anything you write
in shorthand can also be written in plain English; it just takes longer.
Similarly, Common Lisp macros don’t let you say anything that can’t be
expressed with ordinary functions, but they do help you to say things more
concisely

A good example is INCF. It is quicker to write (INCF A) than
(SETF A (+ A 1)). Some macros are very clever, especially the generalized assignment
macros like SETF and INCF. They are able to interpret arbitrarily complex
place descriptions as generalized variable references. When you write an
expression like:
|#

(incf (aref (nth array-num *list-of-arrays*)
            (first subscripts)))

;; you’re relying on the cleverness of INCF to figure out what this place description means
;; Macros can generate complicated programs from simple instructions.
;; The DEFSTRUCT macro, for example, turns a structure definition for STARSHIPs
;; into a long stream of instructions for supporting the STARSHIP datatype.
;; These include function definitions for MAKE-STARSHIP and STARSHIP-P,
;; and accessor functions for all the STARSHIP’s components, such as
;; STARSHIP-NAME. Not only would it be a lot of work to type in all these
;; definitions by hand, but some of what DEFSTRUCT produces is
;; implementation dependent. For example, the instructions for entering
;; STARSHIP as a part of the Common Lisp type hierarchy differ from one
;; Common Lisp implementation to the next. They involve functions and
;; variables that aren’t part of the Common Lisp standard, and probably aren’t
;; even documented by the Lisp vendor. The DEFSTRUCT macro allows Lisp
;; vendors to hide these messy details from their customers by providing an
;; agreed-upon, standard way to define structures that works in every Common
;; Lisp implementation.


;;; 14.3 MACRO EXPANSION

#|
If you write something in shorthand, eventually it will have to be ‘‘expanded’’
into plain English to understand and act on it. Lisp automatically expands
macro calls for the same reason. A macro is actually a special shorthand-
expanding function that does not evaluate its arguments. Its job is to look at
its arguments and produce an expression that Lisp can evaluate. In the case of
(INCF A), the INCF macro is called on the (unevaluated) argument A.

It constructs an expression such as (SETQ A (+ A 1)), which it returns. The
exact expression INCF constructs is implementation dependent, but it will
look something like this SETQ. Lisp then evaluates the expression, and
increments the value of A.

Recall from Section 10.10 that the SETQ special function performs
assignment on ordinary variables. When you use SETF to assign to an
ordinary variable, the SETF macro actually expands into a call to SETQ.

If you want to look at macro expansions on the computer, you can use a
little tool called PPMX, defined in the Lisp Toolkit section of this chapter.
The name PPMX stands for ‘‘Pretty Print Macro eXpansion.’’ Some Lisp
editors also provide commands for displaying macro expansions; see your
user’s manual.
|#

(defparameter *store-a* 1)

(defun setf-a ()
  (setf *store-a* (modified-incf *store-a*)))

> (ppmx (incf a))
Macro expansion:
(SETQ A (+ A 1))

#|
In some Lisp implementations INCF expands differently. For example, it
might expand into a LET expression that creates a local variable to hold the
value of (+ A 1), and then stores that value back into A. This may seem a
rather indirect approach to incrementing A, but remember that INCF is
designed to handle much more complex cases involving generalized
assignment. In those cases a LET may really be necessary.
|#

> (ppmx (incf a))
Macro expansion:
(LET ((#:G0144 (+ A 1)))
  (SETQ A #:G0144))

#|
In the example above, #:G0144 is an internal symbol, called a gensym. It
was automatically generated by INCF to serve as a local variable name.
Gensyms are guaranteed not to conflict with the names of any of your
variables. For reasons we won’t go into here, #:G0144 is a different symbol
than G0144. You cannot type this symbol from the keyboard, so it will never
conflict with any variable in your program, even if you happen to choose the
name G0144.
|#

(incf 1)

;;; 14.4 DEFINING A MACRO


;; SIMPLE-INCF must be written as a macro
;; Macros are defined with DEFMACRO. Its syntax is similar to DEFUN. Let’s
;; define a simplified version of INCF to increment ordinary variables. Our
;; macro will take a variable name as input and construct an expression to
;; increment that variable by one.

(defmacro simple-incf (var)
  (list 'setq var (list '+ var 1)))


REPL> (setf a 4)
REPL> (simple-incf a) --> 5

REPL> (ppmx (simple-incf a))
Macro expansion:
(SETQ A (+ A 1))

;; Now let’s modify SIMPLE-INCF to accept an optional second argument
;; specifying the amount by which to increment the variable. We do this with the
;; &OPTIONAL lambda-list keyword. (Optional arguments were explained in
;; Advanced Topics section 11.13.) The default amount to increment the
;; variable will be one.

(defmacro modified-incf (var &optional (amount 1))
  (list 'setq var (list '+ var amount)))

REPL> (setf a 3)
REPL> (modified-incf a)
REPL> a --> 4


;; Let’s now consider why INCF has to be a macro rather than a function.
;; Suppose we try to make an INCF function, using DEFUN. We’ll call it
;; FAULTY-INCF.

(defun faulty-incf (var)
  (setq var (+ var 1)))

REPL> (faulty-incf c) ---> 8
REPL> c --> 7

;; The input to FAULTY-INCF is the number seven. FAULTY-INCF creates
;; a local variable named VAR to hold its input, and then it increments VAR by
;; one. It doesn’t know anything about the variable A, because its argument was
;; evaluated before the function was entered.

#|
Key Differences Summarized between modified-incf and faulty-incf

Macro vs Function:
modified-incf - macro operates at compile-time, generating code that modifies the variable directly, ensuring global modification.
faulty-incf   - function operates at runtime and modifies a local copy of the variable, failing to affect the global value.

Behavior:
modified-incf - ensures that the increment operation (setq var (+ var amount)) modifies the global variable var
faulty-incf   - mistakenly modifies a local variable var, leaving the global variable unchanged.

Correctness:
modified-incf - correctly modifies global state as intended
faulty-incf   - incorrectly modifies local state, failing to achieve the intended global modification.
|#

;; 14.3. Write a SET-NIL macro that sets a variable to NIL.
(defmacro set-nil (var)
  (list 'setq var nil))

;;; 14.5 MACROS AS SYNTACTIC EXTENSIONS


#|
Since the purpose of macros is to extend the syntax of the language, Lisp does
not treat a macro call like an ordinary function call. There are three important
differences between ordinary functions and macro functions:


1. The arguments to ordinary functions are always evaluated; the arguments to
macro functions are not evaluated.

2. The result of an ordinary function can be anything at all; the result returned
by a macro function must be a valid Lisp expression.

3. After a macro function returns an expression, that expression is
immediately evaluated. The results returned by ordinary functions do not
get evaluated.

In addition to macros, Common Lisp also includes a small number of
special functions. Some examples are SETQ, IF, LET, and BLOCK. Special
functions are the lowest level building blocks of Common Lisp; they are
responsible for things like assignment, scoping, and basic control structure
such as blocks and loops. Like macros, special functions do not evaluate their
arguments, but they also don’t return expressions to be evaluated. They are
primitives that do very special things. You cannot write new special
functions; only a Lisp implementor can do that.

Returning to our discussion of macros as shorthand, we should say that
anything that can be done with a macro can also be done without macros, by
using a combination of ordinary Common Lisp functions, special functions,
and in some cases, implementation dependent functions.
|#

;;; 14.6 THE BACKQUOTE CHARACTER


;; SIMPLE-INCF constructed a Lisp expression by combining two calls to LIST,
;; some quoted symbols, and the values of the variables VAR and AMOUNT.
;; This approach works well enough when the expression is small, but when
;; macros must produce large, complicated expressions, it is awkward to
;; construct them bit by bit. What we need instead is a way to write a template
;; for the expression the macro is to return. Then all the macro has to do is fill in
;; the blanks. The backquote character provides such a facility.

;; The backquote character (‘) is analogous to quote, in that both are used to
;; quote lists. However, inside a backquoted list, any expression that is preceded
;; by a comma is considered to be ‘‘unquoted,’’ meaning the value of the
;; expression rather than the expression itself is used.

REPL> (setf name 'Adrian)
REPL> `(this is ,name from Philippines)
REPL> `(i gave ,name about ,(* 25 8) dollars)

;; We can use backquote to write a more concise version of the SIMPLE-INCF macro:

(defmacro simple-incf (var &optional (amount 1))
  `(setq ,var (+ ,var ,amount)))

;;; EXERCISE


;; 14.4. Write a macro called SIMPLE-ROTATEF that switches the value of
;; two variables. For example, if A is two and B is seven, then (SIMPLE-
;; ROTATEF A B) should make A seven and B two. Obviously, setting
;; A to B first, and then setting B to A won’t work. Your macro should
;; expand into a LET expression that holds on to the original values of the
;; two variables and then assigns them their new values in its body.

(defmacro simple-rotatef (var1 var2)
  `(let ((temp1 ,var1)
         (temp2 ,var2))
     (setf ,var1 temp2)
     (setf ,var2 temp1)))

> (setf a 7)
> (setf b 2)

> (simple-rotatef a b)

> a --> 2
> b --> 7

(defun use-macro-example ()
  (let ((x 10)
        (y 20))
    (multiple-value-bind (new-x new-y)
        (simple-rotatef x y)
      (format t "Back in the function: ~a and ~a~%" new-x new-y))))

(defmacro simple-rotatef (var1 var2)
  `(let ((temp1 ,var1)
         (temp2 ,var2))
     (setf ,var1 temp2)
     (setf ,var2 temp1)
     (format t "Swapped values: ~a and ~a~%" ,var1 ,var2)
     (values ,var1 ,var2)))

(defmacro simple-rotatef (var1 var2)
  `(let ((temp1 ,var1)
         (temp2 ,var2))
     (setf ,var1 temp2)
     (setf ,var2 temp1)
     (values ,var1 ,var2)))

(defun use-macro ()
  (let ((x (setf *a* 'adi))
        (y (setf *b* 'villareal)))
    (multiple-value-bind (new-x new-y)
        (simple-rotatef x y)
      (format t "Hello there ~a and ~a" new-x new-y)
      ;; Update global variables with rotated values
      (setf *a* new-x) (setf *b* new-y))))

(defparameter *a* nil)
(defparameter *b* nil)

;; A very common use of macros is to avoid having to quote arguments. The
;; macro expands into an ordinary function call with quoted versions of the
;; arguments filled in where needed. You can use backquote to generate
;; expressions with quotes in them by including the quotes as part of the
;; template, like this:

`(setf foo 'bar) ⇒ (setf foo ’bar)

;; In the example below, TWO-FROM-ONE is a macro that takes a function
;; name and another object as arguments; it expands into a call to the function
;; with two arguments, both of which are the quoted object.

(defmacro two-from-one (func object)
  `(,func ',object ',object))

CHAPTER-14> (two-from-one list adi)
(ADI ADI)
CHAPTER-14> (two-from-one cons adi)
(ADI . ADI)

;;; EXERCISE:


;; 14.5. Write a macro SET-MUTUAL that takes two variable names as input
;; and expands into an expression that sets each variable to the name of
;; the other. (SET-MUTUAL A B) should set A to ’B, and B to ’A.

(defmacro set-mutual (var1 var2)
  `(progn
     (setf ,var1 ',var2)
     (setf ,var2 ',var1)))

CHAPTER-14> (setf a 1)
1
CHAPTER-14> (setf b 2)
2
CHAPTER-14> (set-mutual a b)
A
CHAPTER-14> a
B
CHAPTER-14> b
A

;; Let’s try a more complex example of backquote. We’ll write a macro
;; SHOWVAR that displays the value of a variable, like this:

(defun f (x y)
  (showvar x)
  (showvar y)
  (* x y))

(defun a (x y)
  (showvar x)
  (showvar y)
  (showvar-1 "Addition")
  (format t "~&The result is: ~d" (+ x y)))

(defmacro showvar (var)
  `(format t "~&The Value of ~S is ~S" ',var ,var))

(defmacro showvar-1 (var1)
  `(format t "~&The Operation used is ~S" ',var1))

REPL> (f 3 7)
The value of X is 3
The value of Y is 7
21

;; When you removed the quoted (') in ,var it will treat the symbol as evaluated value. so the result will be
;; The value of 3 is 3
;; The value of 7 is 7
;; So for a good practice I should remember having a quoted symbol ensures that the variable or expression passed to the macro is treated as a literal symbol

;;; 14.8 THE COMPILER


;; The compiler translates Lisp programs into machine language. This makes
;; programs run faster: the typical speedup is a factor of 10 to 100. As a
;; beginning Lisp programmer you are probably not writing very large programs,
;; so speed may not be a concern. However, as you tackle more ambitious
;; problems, you will eventually find yourself concerned with performance
;; issues such as how fast a program runs and how much memory it uses.
;; Compilation can reduce both figures.

;; There are two ways to use the compiler. You can compile a single function
;; using COMPILE, or an entire file using COMPILE-FILE. Many Lisp-
;; oriented editors provide ways for you to invoke the compiler with just a
;; keystroke or two, so you may never need to call these functions explicitly.

;; Let’s take a look at the effect of COMPILE on the running time of a simple
;; function. This function returns the smallest integer larger than the square root
;; of its input. It computes the result in a very tedious way, but that will help us
;; measure the speedup achieved by compilation.

(defun tedious-sqrt (n)
  (dotimes (i n)
    (if (> (* i i) n) (return i))))

> (time (tedious-sqrt 5000000))
> (compile 'tedious-sqrt)

;;; 14.9 COMPILATION AND MACRO EXPANSION

;; The Common Lisp standard permits macro calls to be replaced by their
;; expansions at any time. In some Lisp implementations DEFUN does the
;; macro expansion right away. In others the macro call gets replaced the first
;; time the function is evaluated. In very simple implementations a macro call
;; may never be replaced with the resulting expansion; instead the macro is
;; expanded anew each time the expression is evaluated.

;; Since macro expansion can happen at any time, you should not write
;; macros that produce side effects, such as assignments or i/o. But it’s fine for
;; the macro to expand into an expression that produces side effects.

(defmacro bad-announce-macro ()
  (format t "~%Hi mom!"))

(defun say-hi ()
  (bad-announce-macro))

> (compile 'say-hi)
Hi, Mom!
SAY-HI

> (say-hi)
NIL

;; In the above example the macro was expanded as part of the process of
;; compiling SAY-HI. So the compiler said ‘‘Hi, mom!’’ The result of the
;; macro was NIL, so that’s what got compiled into the body of SAY-HI. When
;; we call the compiled SAY-HI function, it says nothing because the macro has
;; been replaced with its expansion. The problem can be resolved by making the
;; macro return the FORMAT expression instead of executing it.

(defmacro good-announce-macro ()
  `(format t "~%Hi mom!"))

;;; 14.10 COMPILING ENTIRE PROGRAMS


;; When you compile an entire program, it will generally be stored in a file. You
;; can use the COMPILE-FILE function on the file. Some Lisp editors allow
;; you to do this with an editor command. They may also allow you to compile
;; the contents of an editor buffer without writing it to a file. See your user’s
;; manual for details.


;; Because of the way compilers work, you will need to follow a few simple
;; rules for organizing your program. If you don’t follow these rules, the
;; compiler may produce error messages and not compile your program
;; correctly.

;; First, if your program uses any global variables, the compiler may issue a
;; warning message saying that the variable was ‘‘assumed to be SPECIAL.’’
;; Special variables are explained in the Advanced Topics section. You can get
;; rid of these warnings by declaring the variables with DEFVAR,
;; DEFPARAMETER, or DEFCONSTANT. The declaration should occur early
;; in the file, prior to any function that references those variables. You can also
;; ignore the warnings if you choose.

;; Second, if your program contains macros, the macro definitions must be
;; placed earlier in the file than any functions that reference them. Otherwise, if
;; function FOO calls a macro BAR, Lisp may not realize when compiling FOO
;; that it needs to treat the call to BAR as a macro call to be expanded. If FOO
;; has been compiled incorrectly, most compilers will issue a warning when they
;; find out that BAR is a macro.

;; Third, if your program redefines any built-in functions, the compiler may
;; not handle it correctly. Be sure to use names that don’t conflict with built-in
;; functions. Online documentation can help you check for this.

;; Macros are Lisp’s version of shorthand, with several uses. They allow
;; programmers to define syntactic extensions to Lisp and to say things more
;; concisely. They also help Lisp implementors hide messy implementation-
;; specific details from their customers. Macros do not evaluate their arguments;
;; they return Lisp expressions that are evaluated. New macros can be defined
;; with DEFMACRO.

;; Like macros, special functions do not evaluate their inputs. But unlike
;; macros, they do not return Lisp expressions that are to be evaluated. Special
;; functions provide the primitives on which Lisp is built, such as assignment,
;; conditionals, and block structure.

;; The backquote character constructs a list from a template. If a template
;; element is preceded by a comma it will be evaluated; the value is then inserted
;; into the list being constructed. Elements preceded by a comma and at sign
;; combination are spliced into the list rather than inserted. Backquote is
;; particularly useful in macros that construct complex expressions by filling in
;; the blanks of a template.

;; FUNCTIONS COVERED IN THIS CHAPTER
;; Macro definition: DEFMACRO.
;; Compiler: COMPILE, COMPILE-FILE.

;;; Advanced Topics


;; 14.12 THE &BODY LAMBDA-LIST KEYWORD
;; One reason people write macros is so they can add new bits of syntax to Lisp.
;; For example, we can write a WHILE macro to provide the same control
;; structure as WHILE loops in other languages.

(defmacro while (test &body body)
  `(do ()
    ((not ,test))
     ,@body))

;; The WHILE macro takes a test expression as its first argument, followed
;; by zero or more body expressions to be evaluated if the test is true. The body
;; expressions could be collected with &REST, but Common Lisp includes a
;; special keyword, &BODY, to use when the remaining arguments to a macro
;; form the body of some control structure. Some Lisp editors pay special
;; attention to the &BODY keyword when indenting calls to macros. The use of
;; &BODY also signifies to human readers of the macro definition that the
;; remaining arguments are a body of Lisp code.

;; The NEXT-POWER-OF-TWO function below uses a WHILE loop to
;; repeatedly double the value of the variable I, starting from one, up to the first
;; power of two that is greater than the input N.

(defun next-power-of-two (n &aux (i 1))
  (while (< i n)
         (format t "~&Not ~S" i)
         (setf i (* i 2)))
  i)

;;; 14.13 DESTRUCTURING LAMBDA LISTS

;; The MIX-AND-MATCH macro takes two pairs as input and returns an
;; expression that produces four pairs:

(defmacro mix-and-match (p q)
  (let ((x1 (first p))
        (y1 (second p))
        (x2 (first q))
        (y2 (second q)))
    `(list '(,x1 ,y1)
      '(,x1 ,y2)
      '(,x2 ,y1)
      '(,x2 ,y2))))

REPL>(mix-and-match (fred wilma) (barney betty))
((FRED WILMA) (FRED BETTY) (BARNEY WILMA)
              (BARNEY BETTY))

;; In this example we took apart the two inputs (FRED WILMA) and
;; (BARNEY BETTY) manually, using a LET expression. But since macros
;; don’t evaluate their inputs, they are able to treat input expressions as list
;; structures to be taken apart automatically. This is known as destructuring.
;; You can specify how to destructure an input expression by replacing a variable
;; in the macro’s argument list with another whole argument list. For example,
;; we can replace the variable P in MIX-AND-MATCH with the argument list
;; (X1 Y1), and the variable Q with (X2

(defmacro mix-and-match ((x1 y1) (x2 y2))
  `(list '(,x1 ,y1)
    '(,x1 ,y2)
    '(,x2 ,y1)
    '(,x2 ,y2)))

;; Destructuring is only available for macros, not ordinary functions. It is
;; particularly useful for macros that define new bits of control structure with a
;; complex syntax. The DOVECTOR macro that follows is modeled after
;; DOTIMES and DLIST. It steps an index variable through successive elements
;; of a vector. The macro uses destructuring to pick apart the index variable
;; name, the vector expression, and the result form.


(defmacro dovector ((var vector-exp
                     &optional result-form)
                    &body body)
  `(do* ((vec-dov ,vector-exp)
         (len-dov (length vec-dov))
         (i-dov 0 (+ i-dov 1))
         (,var nil))
	((equal i-dov len-dov) ,result-form)
     (setf ,var (aref vec-dov i-dov))
     ,@body))


REPL> (dovector (x '#(foo bar baz)) (format t "~&X is ~S" x))

X is FOO
X is BAR
X is BAZ
NIL

;;; 14.14 MACROS AND LEXICAL SCOPING


;; Let’s return to our consideration of FAULTY-INCF, an attempt to implement
;; INCF as a function rather than a macro. Suppose we quote the variable before
;; passing it to the function, by writing (FAULTY-INCF ’A). FAULTY-INCF
;; needs to do two things: It must find out the current value of the variable, and it
;; must replace that value with a new one.
;; In the case of global variables this is possible. Recall that a global lives in
;; the value cell of the symbol that names it. We can use the built-in function
;; SYMBOL-VALUE to access the value cell. We can store into this cell by
;; using SETF or by using the built-in SET function discussed in Section 10.10.
;; Here is our new version of FAULTY-INCF:

(defun faulty-incf (var)
  (set var (+ (symbol-value var) 1)))

(setf a 7)
> (faulty-incf ’a)
8
> (faulty-incf ’a)
9
> a
9

;; The function appears to work correctly, but it will only work for global
;; variables. If we try to use it on a local variable, it will fail. SIMPLE-INCF
;; works correctly for either local or global variables.
(defun test-simple (turnip)
  (simple-incf turnip))

(defun test-faulty (turnip)
  (faulty-incf 'turnip))

> (test-simple 37)
38
> (test-faulty 37)
Error: TURNIP unassigned variable.

;; One of the nice features of macros is that their syntax is identical to that of
;; ordinary and special functions. This makes it easy for programmers to make
;; syntactic extensions to Lisp in an invisible way: people who use the extensions
;; can’t tell that they are programmer defined rather than built in. In contrast, in
;; languages like Pascal it is not possible to add new statement types, only new
;; procedures. The only ways to extend the syntax of Pascal are to write a
;; preprocessor or modify the compiler. Both approaches are impractical if you
;; want to be able to combine extensions contributed by several programmers.
;; Many features of Common Lisp originated in earlier dialects as some
;; programmer’s private macro package.
;; Examples include the SETF,
;; DEFSTRUCT, and WITH-OPEN-FILE macros. Even DEFMACRO was
;; originally an extension. (Although Lisp has had macros from the very
;; beginning, before DEFMACRO came along they had to be defined in a more
;; cumbersome way.)
;; Lisp has evolved continuously over its 30-year history, with many people
;; contributing good ideas for extensions. This evolution would not have been
;; possible without macros. Besides extending Lisp, macros can also be used to
;; define entirely new languages. Specialized high-level languages for artificial
;; intelligence programming are often built on top of Lisp this way. The figures
;; in this book were created using a specialized graphics language implemented as Common Lisp macros.

;; 14.16 DYNAMIC SCOPING


;; Throughout this book we have used lexical scoping for all variables. Lexical
;; scoping means that in order for a function FOO to access a variable X, the
;; definition of FOO must appear within the context where X is defined. If FOO
;; is defined at top level with DEFUN, then it can only access global variables
;; (plus whatever locals it defines itself.) But if a function is defined by a
;; lambda expression appearing inside the body of another function BAR, then it
;; can access BAR’s local variables as well as its own. Functions defined
;; outside of BAR cannot access any of BAR’s variables.
;; The alternative to lexical scoping is called dynamic scoping. Prior to
;; Common Lisp, dynamic scoping was the norm in Lisp. Lexical scoping was
;; found only in two offshoot dialects called Scheme and T.


;; Dynamically scoped variables are also called special variables. When a
;; variable name is declared to be special, that variable will not be local to any
;; function; its value will be accessible anywhere. In contrast, lexically scoped
;; variables are accessible only within the body of the form that defines them.
;; One way to declare a variable name special is with the DEFVAR macro.

(defvar birds)

;; Let’s compare the effects of lexical versus dynamic scoping of variables.
;; We’ve declared BIRDS to be dynamically scoped. We’ll use FISH as a
;; lexically scoped variable, so it should not be DEFVARed. Each variable will
;; be assigned an appropriate initial value below; then we’ll write a function to
;; reference the value of each variable.


(setf fish ’(salmon tuna))

(setf birds ’(eagle vulture))

(defun ref-fish ()
  fish)

(defun ref-birds ()
  birds)


;; Now to see the difference between the two scoping disciplines, we’ll write
;; functions that name their inputs FISH and BIRDS. First, we’ll consider the
;; familiar, lexically scoped case using FISH.

(defun test-lexical (fish)
  (list fish (ref-fish)))


;;; 14.17 DEFVAR, DEFPARAMETER, DEFCONSTANT

;; DEFVAR, DEFPARAMETER, and DEFCONSTANT all declare names to be
;; special. DEFVAR is used for declaring variables whose values will change
;; during the normal operation of the program. It accepts an optional initial
;; variable value and a documentation string.

(defvar *total-glasses* 0
  "Total glasses sold so far")
*TOTAL-GLASSES*

;; A curious fact about DEFVAR is that if the variable already has a value,
;; DEFVAR will not change it. It only assigns the initial value if the variable has
;; none.

(defvar *total-glasses-1* 3)

*TOTAL-GLASSES*
> *total-glasses*
0


;; DEFPARAMETER has the same syntax as DEFVAR, but it is used to
;; declare variables whose values will not change while the program runs. They
;; hold ‘‘parameter settings’’ that tell the program how to behave. Another
;; difference between DEFPARAMETER and DEFVAR is that
;; DEFPARAMETER will assign a value to a variable even if it already has one.

(defparameter *max-glasses* 500)
(defparameter *max-glasses* 300)

;; DEFCONSTANT is used to define constants, which are guaranteed never
;; to change. The convention in Lisp is to surround the names of special
;; variables with an asterisk, but this does not apply to constants. It is an error to
;; try to change the value of a constant, or to create a new variable with the same
;; name as a constant. PI is a built-in constant in Common Lisp.

(defconstant +speed-of-light-1+ 299792500.0)


;; 14.18 REBINDING SPECIAL VARIABLES
#|

Much of Lisp’s terminology for variables is a holdover from the days when
dynamic scoping was the norm. For historical reasons some writers talk about
‘‘binding a variable’’ when they mean ‘‘creating a new variable.’’ But people
also say ‘‘unbound variable’’ when they mean ‘‘unassigned variable.’’
Binding does not refer strictly to assignment; that is one of the major sources
of terminological confusion in Lisp. Nonglobal lexical variables always have
values, but it is possible for global or special variables to exist without a value.
We won’t get into the arcane details of that in this book.

We have avoided confusion so far by declining to use the term ‘‘binding’’
at all. In this final section we introduce the term ‘‘rebinding’ to refer to the
creation of a new special variable with the same name as the old one. While
the new variable is in existence, all uses of that name anywhere in the program
will refer to it (unless the name is rebound yet again), and the previous
variable with that name will be inaccessible. Strictly speaking, we aren’t
rebinding any variable: We’re dynamically rebinding the name, making it
refer temporarily to a different variable.

Common Lisp contains quite a few built-in special variables. Some of
these control the way input/output is handled. For example, the variable
*PRINT-BASE* is used by FORMAT and other functions to determine the
base in which numbers are to be printed. Normally they are printed in base
ten. We can dynamically rebind *PRINT-BASE* to print numbers in other
bases. Since it is already declared special, we don’t have to DEFVAR it. To
rebind it, we merely include it in the argument list of our function.

|#

(defun print-in-base (*print-base* x)
  (format t "~&~D is written ~S in base ~D."
          x x *print-base*))

(defmacro showvar (var)
  `(format t "~&The Value of ~S is ~S" ',var ,var))

(defvar *foo* 2)

(defun bump-foo ()
  (incf *foo*))

(defun rebind-foo ()
  (bump-foo)
  (showvar *foo*)
  (let ((*foo* 100))
    (format t "~&Enter the LET...~%")
    (showvar *foo*)
    (incf *foo*)
    (showvar *foo*)
    (bump-foo)
    (showvar *foo*)
    (format t "~&Leave the LET.~%"))
  (bump-foo)
  (showvar *foo*))


;; Rebinding of special variables is most useful when different parts of a
;; large program need to communicate with each other, and passing information
;; via extra arguments to functions is impractical. Writing really large programs
;; requires a different set of skills than what this book emphasizes; it is a good
;; topic for an advanced Lisp course.


;; FUNCTIONS COVERED IN ADVANCED TOPICS
;; DEFMACRO: the &BODY lambda list keyword.
;; Declarations: DEFVAR, DEFPARAMETER, DEFCON










;;; Macros (other reference)
'
'
'
'
'
'
'
'
'
'
'
;;; Taking some code and transforming and returning some new code that will be used in its place.

;;; A. READ STAGE (Take strings)
;; --Read a macros

;;; B. TRANSFORM STAGE
;; --symbol macros
;; --defmacro
;; --compiler macros

;;; C. COMPILATION STAGE (compiling it down)

;;; D. RUN (executing where to see an effect)

;;; READ FROM STRINGS
(defun foo (x)
  (+ x 10))

CHAPTER-14> (read-from-string "(defun foo (x) (+ x 10))")
(DEFUN FOO (X) (+ X 10))
24
CHAPTER-14> (type-of +)
CONS
CHAPTER-14> (first (read-from-string "(defun foo (x) (+ x 10))"))
DEFUN
CHAPTER-14> (second (read-from-string "(defun foo (x) (+ x 10))"))
FOO
CHAPTER-14> (last (read-from-string "(defun foo (x) (+ x 10))"))
((+ X 10))
CHAPTER-14> (third (read-from-string "(defun foo (x) (+ x 10))"))
(X)


(defun bar (x)
  (cond ((eql x 5) :hi)
        ((eql x 10) :bye)
        ((eql x 15) :boo)))

CHAPTER-14> (bar 5)

:HI
CHAPTER-14> (bar 10)
:BYE
CHAPTER-14> (bar nil)
NIL
CHAPTER-14> (bar :foo)
NIL

;;;ugly version of bar

(defun bar (x)
  (if (eql x 5)
      :hi
      (if (eql x 10)
          :bye
          (if (eql x 15)
              :boo
              nil))))


;;;unevaluated code using quote

'(cond ((eql x 5) :hi)
  ((eql x 10) :bye)
  ((eql x 15) :boo))

(COND ((EQL X 5) :HI) ((EQL X 10) :BYE) ((EQL X 15) :BOO))


;;;using macro-expand

(macroexpand '(cond ((eql x 5) :hi)
               ((eql x 10) :bye)
               ((eql x 15) :boo)))
RESULT:
(IF (EQL X 5)
    :HI
    (IF (EQL X 10)
        :BYE
        (IF (EQL X 15)
            :BOO
            NIL)))
T

(defun baz (x)
  (case (length x)
    (0 :hi)
    (1 :bye)
    (2 :boo)))

;; Macro-expand -- c-return

(LET ((#:G250 (LENGTH X)))
  (DECLARE (IGNORABLE #:G250))
  (COND ((EQL #:G250 '0) NIL :HI) ((EQL #:G250 '1) NIL :BYE)
        ((EQL #:G250 '2) NIL :BOO)))

;; if hit again the c-return to the expression
(LET ((#:G250 (LENGTH X)))
  (DECLARE (IGNORABLE #:G250))
  (IF (EQL #:G250 '0)
      (PROGN NIL :HI)
      (IF (EQL #:G250 '1)
          (PROGN NIL :BYE)
          (IF (EQL #:G250 '2)
              (PROGN NIL :BOO)
              NIL))))

;; if hit "G" the variable numbers will referesh and changing

(LET ((#:G254 (LENGTH X)))
  (DECLARE (IGNORABLE #:G254))
  (COND ((EQL #:G254 '0) NIL :HI) ((EQL #:G254 '1) NIL :BYE)
        ((EQL #:G254 '2) NIL :BOO)))

;;;backtick and comma

`(1 2 3) ---> (1 2 3)
`(1 ,(+ 1 2) a 3) ---> (1 3 A 3)

;;;splice
`(1 ,@(loop :for i below 10 collect i) a 3) --> (1 0 1 2 3 4 5 6 7 8 9 A 3)

;;;another example using OOP and macro

(defclass handle ()
  ((resource :initarg :resource
             :initform nil)))

(defmethod dispose (obj)
  nil)

(defmethod dispose ((obj handle))
  (format t "~%Disposing: ~a"
          (slot-value obj 'resource))
  nil)

;; USAGE
;; CHAPTER-14> (defparameter *my-handle* (make-instance 'handle :resource "Example Resource"))

;; *MY-HANDLE*

;; CHAPTER-14> (dispose *my-handle*)
;; Disposing: Example Resource
;; NIL


;; CHAPTER-14> (defparameter *my-handle-1* (make-instance 'handle :resource "wow"))
;; *MY-HANDLE-1*

;; CHAPTER-14> (dispose *my-handle-1*)
;; Disposing: wow
;; NIL

;; CHAPTER-14> (dispose *my-handle*)
;; Disposing: Example Resource
;; NIL

;;;ugly code test, that will be based using regular function to form a macro for my OOP
(defun test ()
  (let ((x (make-instance 'handle :resource "hello")))
    (unwind-protect
         (progn (print "lots of work happening"))
      (dispose x))))

;;;doing the macro step-by-step into regular function into defmacro
(defun gen-using-code (var form body)
  `(let ((,var ,form))
     (unwind-protect
          (progn ,@body)
       (dispose ,var))))

(defmacro using (var form &body body)
  (print var)
  (print form)
  (print body)
  `(let ((,var ,form))
     (unwind-protect
          (progn ,@body)
       (dispose ,var))))

(defun test-2 ()
  (using x (make-instance 'handle :resource "hello")
         (print "lots-of-work happening")))

;;; c-return (looking at macroexpansion)
(LET ((X (MAKE-INSTANCE 'HANDLE :RESOURCE "hello")))
  (UNWIND-PROTECT (PROGN (PRINT "lots-of-work happening")) (DISPOSE X)))

;;;compile time
SBCL> X 
(MAKE-INSTANCE 'HANDLE :RESOURCE "hello") 
((PRINT "lots-of-work happening"))


;;;final test

(defclass handle ()
  ((resource :initarg :resource
             :initform nil)))

(defmethod dispose (obj)
  nil)

(defmethod dispose ((obj handle))
  (format t "~%Disposing: ~a"
          (slot-value obj 'resource))
  nil)


(defmacro using (var form &body body)
  `(let ((,var ,form))
     (unwind-protect
          (progn ,@body)
       (dispose ,var))))

(defun test-2 (mk-ins)
  (using x mk-ins   
         (print "lots-of-work happening")))


SBCL> (test-2 (make-instance 'handle :resource "wow"))
"lots-of-work happening" 
Disposing: wow
"lots-of-work happening"

;;;Experimentation

(defmacro generate-starship (var form &body body)
  `(let ((,var ,form))
     (unwind-protect
          (progn
            (push ,var *my-spaceships*)
            (incf *spaceship-counter*)
            ,@body)
       (starship ,var))))

(defparameter *my-spaceships* nil)
(defparameter *spaceship-counter* 0)

(defclass star-ship ()
  ((spaceship :initarg :spaceship
              :initform nil)))

(defmethod starship ((name star-ship))
  (format t "~%Ship No. ~a ---> [~a]"  *spaceship-counter* (slot-value name 'spaceship))
  *my-spaceships*)

(defmethod print-object ((ship star-ship) stream)
  "Custom printing behavior for instances of the star-ship class as strings"
  (print-unreadable-object (ship stream :type t :identity t)
    (format stream "~a" (slot-value ship 'spaceship))))

(defun make-starship (make-ship)
  (generate-starship z make-ship
                     (format t "Starship Created")))

(defun show-created-spaceships ()
  (dolist (ship *my-spaceships*)
    (format t "Stored Spaceship: ~a~%" ship))
  (format t "Total Spaceships: ~d~%" *spaceship-counter*))

;; REPL:
(make-starship (make-instance 'star-ship :spaceship "Adiwow"))
(make-starship (make-instance 'star-ship :spaceship "SpacePort"))
(make-starship (make-instance 'star-ship :spaceship "Idallavi"))
(make-starship (make-instance 'star-ship :spaceship "Jedi"))

;;Result:
Starship Created
Ship No. 4 ---> [Jedi]
NIL

;; Show all stored spaceships and count
CHAPTER-14> (show-created-spaceships)
Stored Spaceship: #<STAR-SHIP Jedi {10038296E3}>
Stored Spaceship: #<STAR-SHIP Idallavi {1003828AE3}>
Stored Spaceship: #<STAR-SHIP SpacePort {10037C7FA3}>
Stored Spaceship: #<STAR-SHIP Adiwow {1003727353}>
Total Spaceships: 4

;;------------------------------------------------------------------

;;;Creating a recursive macro
(defun factorial (x &optional (accum 1))
  (cond ((<= x 0) accum)
        (t (baz (1- x) (* accum x)))))

(lambda (x)
  (labels ((fact (x &optional (accum 1))
             (cond ((<= x 0) accum)
                   (t (fact (1- x) (* accum 1))))))
    (fact x)))

(defmacro rlambda (arg-names &body body)
  `(labels ((fact ,arg-names
              ,@body))
     #'fact))

;;;Using rlambda macro
(rlambda (x &optional (accum 1))
         (if (<= x 0)
             accum
             (fact (- x 1) (* accum x))))

;;macro-expansion
(LABELS ((FACT (X &OPTIONAL (ACCUM 1))
           (IF (<= X 0)
               ACCUM
               (FACT (- X 1) (* ACCUM X)))))
  #'FACT)

REPL> (funcall (rlambda (x &optional (accum 1))
                        (if (<= x 0)
                            accum
                            (fact (- x 1) (* accum x))))
               4)

> 24


;;-------------------------------------------------------------------
;;;symbol-macrolet

(defun test-3 (key ht)
  (symbol-macrolet ((x (gethash key ht)))
    (list x x x)))

(defun test-4 (obj)
  (with-slots (resource) obj
    (print resource)
    (setf resource "yay")
    (print resource)
    obj))

(LET ((#:G271 OBJ))
  (SYMBOL-MACROLET
      ((RESOURCE (SLOT-VALUE #:G271 'RESOURCE)))
    (PRINT RESOURCE)
    (SETF RESOURCE "yay")
    (PRINT RESOURCE)
    OBJ))

;;;NOTE: The special form symbol-macrolet is the basic mechanism that is used to implement with-slots.
;;;Example
(symbol-macrolet ((x '(foo x)))
  (list x))


;;;1:32:41
